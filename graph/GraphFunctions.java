Map<Integer, List<Integer>> buildGraph(int[][] edges, int n, boolean directed){} [p0]
boolean hasEdge(Map<Integer, List<Integer>> graph, int u, int v) {} [p1]
void deleteEdge(Map<Integer, List<Integer>> graph, int u, int v, boolean directed){} [p1]
boolean isCompleteGraph(Map<Integer, List<Integer>> graph, int n){} [p1]
boolean isBipartite(int[][] graph){} [p1]
void dfs(int node, Set<Integer> visited, Map<Integer, List<Integer>> graph){} [p0]
void bfs(int startNode, Map<Integer, List<Integer>> graph){} [p0]
boolean hasCycleUndirected(int n, int[][] edges) [p0]
boolean hasCycleDirected(int n, int[][] edges) [p0]
boolean hasPathDFS(int source, int destination, Map<Integer, List<Integer>> graph) [p1]
boolean hasPathBFS(int source, int destination, Map<Integer, List<Integer>> graph) [p1]
int countConnectedComponents(int n, int[][] edges) [p1]
List<List<Integer>> findAllPaths(int source, int target, Map<Integer, List<Integer>> graph) [p1]
List<Integer> topologicalSortDFS(int n, int[][] edges) [p0]
int[] dijkstra(int n, int[][] edges, int source) [p0]
int findParent(int x) [p1]
void union(int x, int y) [p0]
boolean validTree(int n, int[][] edges) [p0]
int countComponentsUnionFind(int n, int[][] edges) [p1]
List<List<Integer>> findBridges(int n, List<List<Integer>> graph) [p1]
